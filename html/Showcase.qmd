---
title: "Quantitative Metabarcoding"
format: 
  html:
    toc: true
    toc-location: left
    toc-title: "Table of Contents"
    toc-depth: 2
    number-sections: true
    page-layout: full
    self-contained: true 
    collapsible: true
    collapse-level: 1
    grid:
      sidebar-width: 200px
      body-width: 880px
      margin-width: 200px
      gutter-width: 1.5rem
author: Gled Guri
date: "`r format(Sys.time(), '%d %B, %Y')`"
editor: source
editor_options: 
  chunk_output_type: console
---

```{=html}
<style>
body {
  font-family: Arial, sans-serif;
  font-size: 18px;
}

h1 {
  font-size: 22px;  /* Adjust the size of H1 headers */
  font-weight: bold;  /* Make H1 headers not bold */
}

h2 {
  font-size: 18px;  /* Adjust the size of H2 headers */
  font-weight: normal;  /* Make H2 headers not bold */
}

h3 {
  font-size: 18px;  /* Adjust the size of H3 headers */
  font-weight: normal;  /* Make H3 headers not bold */
}

h4 {
  font-size: 18px;  /* Adjust the size of H4 headers */
  font-weight: normal;  /* Make H4 headers not bold */
}
</style>
```

```{r, include=FALSE}
dwidth <- 150
options(width = dwidth)
```

```{r, include=FALSE, warning=FALSE, message=FALSE}
options(width = 300) #wd
```

```{r, include=FALSE, warning=FALSE, message=FALSE}
options(width = dwidth)#wd
```

If you end up using any of the following model please cite [Guri et al., 2024](https://onlinelibrary.wiley.com/doi/full/10.1002/ece3.70678) for models 1 and 2. For models 3 - 5 please cite [Guri et al., 2024](https://academic.oup.com/icesjms/article/81/8/1536/7728836)

This package is designed to simplify complex mathematical processes, allowing researchers, resource managers, and technicians to analyze environmental DNA (eDNA) data without needing advanced mathematical expertise. By using Bayesian inference, the package helps estsimate eDNA concentration from field samples. This package is currently in beta development, and new features and improved documentation are ongoing. Please feel free to reach out with any questions or feedback.

This package includes 5 models that can be used individually or joined within 3 frames of inferences:\
1. qPCR ([M1](#Model_1) & [M2](#Model_2))\
2. Metabarcoding ([M3](#Model_3) & [M4](#Model_4))\
3. qPCR + Metabarcoding ([M5](#Model_5) which jointly estimates M1-M4)

**Directed Acyclic Graph (DAG) of the model overview**

![QM model overview](../Images/Model_layout.jpg)

First things first, load the package and its dependencies.

```{r, warning=FALSE, message=FALSE, results='hide'}
devtools::install_github("gledguri/QM",dependencies = TRUE, force = T )
library(QM)
load_QM_packages()
```

You can load your data but I have included a set of data in the package to work and play with.

```{r, warning=FALSE, message=FALSE, results='hide'}
# data(herring_qpcr);force(herring_qpcr) #extra data to play around with
data(cod_qpcr);force(cod_qpcr)
data(metabarcoding);force(metabarcoding)
```

```{r, include=FALSE, warning=FALSE, message=FALSE}
options(width = 1300) #wd 
```

Let's view the data

```{r}
cod_qpcr
metabarcoding
```

```{r, include=FALSE, warning=FALSE, message=FALSE}
options(width = 300) #wd
```

**Before you run any model**

All the models are designed to be run in similar chain operations:\
\
***(1) Load model --\> (2) Prepare data --\> (3) Run model --\> (4) Extract output --\> (5) Plot output***\

1.  Load model is a function that load and compile the stan model into your local computer by running `load_model('Model number')`. All the stan model are located in the github repository under folder Stan. Loading each model takes slightly less than 1 min.\
2.  Prepare data are a set of functions that converts the data frame into a list that will be thereafter imputed when running the stan model (step 3). For running this function the data should be formatted in a particular form, distinguishing the different samples and their information. Please use `data_example('Model number')` or use `data(cod_qpcr)` or `data(metabarcoding)` to see the data format for required for running prepare data functions. The output of this function is a list.\
3.  Run Stan model is a function that calls the compiled stan model (step 1) and loads the prepared data (step 2) onto the model. The output of this function is a list containing 2 lists (\[1\] data list (created in step 2) and \[2\] stan model output). If you are interested in only looking at the output of the model you can pull out the second list `output_list[[2]]` 4. Extract output are a set of functions that extract the interested parameters from each specific model output (M1 - M5; step 3) hence the functions are tailored for each particular model output and stan model code. To have an overview of all functions please read through this document or check [all functions](#All_functions)\
4.  Plot output are a set of functions that plot the interested parameters from each specific model output (M1 - M5; step 3 and 4) hence the functions are tailored for each particular model output and stan model code. To have an overview of all functions please read through this document or check [all functions](#All_functions). These are standard plots I have created but feel free to generate any plot as you see fit; all model outputs can be extracted either by using `extract_param(model = output_list[[2]], par = 'parameter_name')` or simply by printing out `output_list[[2]]`\

# Model 1 {#Model_1}

Before going to load and run Model 1 and 2 here's a description of the model.\
This model implements a two step model (joint model) to estimate the relationship between DNA concentration (C) and qPCR outcomes (Y and Z). The model jointly combines two compartments (eq. 1.1 - 2.3) to estimate DNA concentration using both Ct values (Y) and positive or negative qPCR amplification outcomes (Z). For detailed explanation please read [Guri et al., 2024](https://onlinelibrary.wiley.com/doi/full/10.1002/ece3.70678).

In short the presence (Z = 1) or absence (Z = 0) of qPCR amplification in sample $i$ in technical replicate $j$ is modeled as a Bernoulli random variable with the probability of amplification $\theta_i$. The probability of amplification arises from a Poisson process with rate parameter $\lambda$. The probability of having no amplification events is given by $e^{-\lambda}$, and thus the probability of positive amplification is $1-e^{-\lambda}$. We model $\lambda$ as a function of concentration where $\lambda = C \cdot \phi$. Hence $\phi$ is the probability that a single target molecule in reaction will lead to a successful amplification event. In the ideal scenario when only one target molecule is in the reaction and it gets successfully amplified, $\phi = 1$.

Additionally the second compartment models the observed Ct values (Y) in sample $i$ in technical replicate $j$ as random variable drawn from a Normal distribution with mean $\mu$ and standard deviation $\sigma$. We model $\mu$ as a linear function of DNA concentration (C) with intercept and slope $\beta0$ and $\beta1$ (Equation 2.2). The standard deviation of the observed Y is an exponential function of DNA concentration with intercept and slope $\gamma0$ and $\gamma1$ (Equation 2.3). Note that $\beta0$ (intercept between Ct and DNA concentration) has subscript $_p$ meaning that is different for every plate. The reason for having a different $\beta0$ is due to the qPCR machine being sensitive to external factors hence every qPCR run has a different $\Delta$Rn (normalized fluorescence signal).

$$
\begin{aligned}
&\textbf{qPCR probability of detection model}\\
Z_{ij} &\sim \text{Bernoulli}(\theta_{i}) && \text{(1.1)} \\
\theta_{i} &= 1 - exp(-C_{i} \cdot \phi) && \text{(1.2)} \\
&\text{}\\
&\textbf{qPCR continuous model}\\
Y_{ij} &\sim \text{Normal}(\mu_{i}, \sigma_{i}) && \text{(2.1)} \\
\mu_{i} &= \beta0_{p} + \beta1 \cdot ln(C_{i}) && \text{(2.2)} \\
\sigma_{i} &= e^{(\gamma0 + \gamma1 \cdot ln(C_{i}))} && \text{(2.3)}
\end{aligned}
$$

## Load the stan model


```{r, warning=FALSE, message=FALSE,results='hide'}
M1 <- load_model('M1')
```

## Prepare the data to be loaded in the model.

The data should be formatted in a particular form. Please use `data_example('M1')` to see the data format for required for Model 1 or use `data(cod_qpcr)` to load the data included in the package.

```{r}
stan_data_M1 <- prep_stan_M1(
   qpcr_data = cod_qpcr %>% filter(Sample_type=="STANDARD"),
   Ct = "Ct",
   standard_concentration = "Std_concentration",
   plate_index = 'Plate')
```

## Run the model.

This chunk runs the Bayesian model (eq. 1.1 - 2.3) using [rstan](https://mc-stan.org/rstan/) where C is the known DNA concentration from the Standard samples, Y is the observed Ct values form the qPCR machine and Z (Z = 1 for positive amplification & Z = 0 for non amplification hence Ct == 'Undetermined').

All the unknown parameters of the model (all Greek letters such as $\phi$, $\beta0_p$, $\beta1$, $\gamma0$, $\gamma1$, $\mu$, $\sigma$, $\theta$) are in stan model output and can be extracted by using `extract_qpcr_param(model_output)` [see below](#Model_1_extract). Note that $\beta0$ (intercept between Ct and DNA concentration) has subscript $_p$ meaning that is different for every plate. The reason for having a different $\beta0$ is due to the qPCR machine being sensitive to external factors hence every qPCR run has a different $\Delta$Rn (normalized fluorescence signal).

```{r}
M1_output <- Run_Model(stan_object = M1, stan_data = stan_data_M1)
```

## Extract outputs {#Model_1_extract}

Here is how you extract the important parameter of the model.

```{r}
extract_qpcr_param(M1_output)
```

## Plot outputs

This chunk extracts the parameters (all Greek letters in eq. 1.1 - 2.3) and plots them in relation to observed values (Ct and Z). Two different plots are generated each representing the two model compartments, the probability of detection model (eq. 1.1 - 1.2) by running `plot_qpcr_prob_det(M1_output)`, and the continuous model (eq. 2.1 - 2.3) by running`plot_qpcr_cont_mod(M1_output)`.

```{r, fig.width=8, fig.height=5}
plot_qpcr_prob_det(M1_output)
plot_qpcr_cont_mod(M1_output)
```

```{r, fig.width=17, fig.height=6}
plot_qpcr_curves(M1_output)
```

Also I made a custom function that can plot the continuous model having the plates as the facet.

```{r, fig.width=15, fig.height=9}
plot_qpcr_cont_mod_plate_specific(M1_output)
```

# Model 2 {#Model_2}

Model 2 builds on [Model 1](#Model_1) by incorporating environmental samples (e.g., field-collected data) alongside standard samples. By sharing parameters learned from the standards (e.g., detection probabilities or Ct-concentration relationships with the known DNA concentration), it estimates the DNA concentration (`C_est_log`) for imputed field samples (`Sample_name`) with credible intervals (`C_est_log_2.5%CI` and `C_est_log_97.5%CI`). The estimated DNA concentration (`C_est_log`) from environmental samples can be extracted from the model output using `extract_est_conc(M2_output)` function [see here](#M2_extract). The mathematical notation is the same as [Model 1](#Model_1) where 2 set of equations (eq 1.1 - 2.3) are used, one for standards and one for the unknown environmental samples where the only join information they share are the model parameters (all Greek letter).

## Load the stan model

```{r, warning=FALSE, message=FALSE,results='hide'}
M2 <- load_model('M2')
```

## Prepare the data to be loaded in the model.

The data should be formatted in a particular form. Please use `data_example('M2')` to see the data format for required for Model 2 or use `data(cod_qpcr)` to load the data included in the package.


```{r}
stan_data_M2 <- prep_stan_M2(
	qpcr_data = cod_qpcr,
	sample_type = "Sample_type",
	Ct = "Ct",
	sample_name_column = "Sample_name",
	standard_concentration = "Std_concentration",
	plate_index = 'Plate')

# Run the model
M2_output <- Run_Model(stan_object = M2, stan_data = stan_data_M2)
```

## Extract outputs {#M2_extract}

```{r, warning=FALSE, message=FALSE}
extract_qpcr_param(M2_output)
extract_est_conc(M2_output) %>% as_tibble()
```

## Plot outputs of Model 2

```{r, fig.width=17, fig.height=6, warning=FALSE, message=FALSE}
plot_qpcr_curves(M2_output)
```

```{r, fig.width=10, fig.height=5, warning=FALSE, message=FALSE}
plot_qpcr_prob_det(M2_output)
plot_qpcr_cont_mod(M2_output)
```

You could change the x limits by adding `xmin_log` and `xmax_log` arguments. The limits are in $log_e$ hence `xmax_log` = $8 = 3 \cdot 10^3$

```{r, fig.width=10, fig.height=5, warning=FALSE, message=FALSE}
plot_qpcr_cont_mod(M2_output,xmin_log = 0,xmax_log = 8)
```

```{r, fig.width=17, fig.height=9, warning=FALSE, message=FALSE}
plot_qpcr_cont_mod_plate_specific(M2_output)
```

Here I provide a standard way of plotting the estimated DNA concentration of environmental (field) samples by putting the samples on x-axis and eDNA concentrations on y-axis. All the DNA concentrations at around $10^{-1.3}$ and very large error bars are basically non-detects indicating that no targeted DNA was found in all technical replicate of the sample.

```{r, fig.width=17, fig.height=8, warning=FALSE, message=FALSE}
plot_est_conc(M2_output)
```


# Model 3 {#Model_3}
Here we establish that the number of observed reads (R) from metabarcoding is a draw from a multinomial distribution given the proportions for each species $\psi$ and the total number of reads per sample T (eq 3.1). We formulate that $\psi$ is the softmax transformation of $\gamma$ the post-PCR log-ratio amplicon abundance. 

which produces proportions for each taxon (μi) from the log-ratios of abundance
Equations 4.2.1 and 4.2.2 link proportions ψ for each species i to observations, via a softmax transformation of the ratios of species abundances γ.

The known initial concentrations of all species i from mock community samples is converted into additive log ratios (alri) relative to a reference species of choice (G. morhua in this study, see Shelton et al. 2023), using the following equation:

where NPCR is the number of PCR cycles used to amplify the amplicons, α is the species-specific amplification efficiency (again, expressed as a log-ratio relative to that of a reference species; see Shelton et al. 2023), and η is the parameter that allows for overdispersion in the counts beyond the variability provided by the multinomial distribution, capturing the substantial variance among replicates often observed in metabarcoding data.

Having estimated the species-specific amplification efficiencies in Equation 4.3.1, we can derive the absolute DNA quantities for each species, station, and year (Cijy), given the known concentration of the reference species (Ci=ref, G. morhua) estimated in Equation 3.2.2 for the same samples.

$$\Large
\begin{align*} 
R_{im}\ &\sim \text {Multinomial} \left(\psi_{im},\ T_m\right) && \text{(3.1)}\\ 
{\vec{\psi}}_{im}&=\frac{e^{{\vec{\gamma}}_{im}}}{\sum_{i=1}^{I}e^{\gamma_{im}}} && \text{(3.2)}\\ 
\gamma_{im}&={alr}_i+\left(NPCR\times\alpha_i\right) && \text{(3.3)}\\ 
 \end{align*}
$$



## Load the stan model

```{r, warning=FALSE, message=FALSE,results='hide'}
M3 <- load_model('M3')
```

## Prepare the data to be loaded in the model.

```{r}
# Trim metabarcoding data only for mock samples
moc_dat <- metabarcoding %>% select(Species,sp_idx,ini_conc,Mock_1:Mock_6)

# # Prepare the data for going into the model
stan_data_M3 <- prep_stan_M3(
	metabarcoding_data = moc_dat,
	mock_sequencing_columns = c('Mock_1','Mock_2','Mock_3','Mock_4','Mock_5','Mock_6'),
	mock_initial_concentration = 'ini_conc',
	species_index = 'sp_idx',
	species_names = 'Species',
	number_of_PCR = 43,
	alpha_magnitude = 0.1)

# Run the model
M3_output <- Run_Model(stan_object = M3, stan_data = stan_data_M3)
```

## Extract outputs

```{r}
extract_amp_efficiecy(M3_output)
amp_eff_output_extract(M3_output)
```

## Plot outputs

```{r, fig.width=17, fig.height=7}
plot_amp_eff(M3_output)
```

# Model 4 {#Model_4}

## Load the stan model

```{r, warning=FALSE, message=FALSE,results='hide'}
M4 <- load_model('M4')
```

## Prepare the data to be loaded in the model.

```{r}
# Get column names for mock samples and environmental samples
mock_columns <- metabarcoding %>% select(Mock_1:Mock_6) %>% names()
sample_columns <- metabarcoding %>% select(-all_of(mock_columns),-Species,-sp_idx,-ini_conc) %>% names()

# Prepare the data for going into the model
stan_data_M4 <- prep_stan_M4(
	metabarcoding_data = metabarcoding,
	mock_sequencing_columns = mock_columns,
	sample_sequencing_columns = sample_columns,
	mock_initial_concentration = 'ini_conc',
	species_index = 'sp_idx',
	species_names = 'Species',
	number_of_PCR = 43,
	alpha_magnitude = 0.1)

M4_output <- Run_Model(stan_object = M4, stan_data = stan_data_M4)
```

## Extract outputs

```{r}
extract_amp_efficiecy(M4_output)
amp_eff_output_extract(M4_output)
```

```{r, include=FALSE, warning=FALSE, message=FALSE}
options(width = 1300) #wd
```

```{r, fig.width=17, fig.height=7}
extract_ini_prop(M4_output)
```

```{r, include=FALSE, warning=FALSE, message=FALSE}
options(width = 300) #wd
```

## Plot outputs

```{r, fig.width=17, fig.height=7}
plot_amp_eff(M4_output)
bar_plot_est_ini_prop(M4_output)
heatmap_plot_est_ini_prop(M4_output)
```

# Model 5 {#Model_5}

## Load the stan model

```{r, warning=FALSE, message=FALSE,results='hide'}
M5 <- load_model('M5')
```

## Prepare the data to be loaded in the model.

```{r,warning=FALSE, message=FALSE,results='hide'}
mock_columns <- metabarcoding %>% select(Mock_1:Mock_6) %>% names()
sample_columns <- metabarcoding %>% select(-all_of(mock_columns),-Species,-sp_idx,-ini_conc) %>% names()

stan_data_M5 <- prep_stan_M5(
	qpcr_data = cod_qpcr,
	sample_type = "Sample_type",
	Ct = "Ct",
	sample_name_column = "Sample_name",
	standard_concentration = "Std_concentration",
	plate_index = 'Plate',
	metabarcoding_data = metabarcoding,
	mock_sequencing_columns = mock_columns,
	sample_sequencing_columns = sample_columns,
	mock_initial_concentration = 'ini_conc',
	species_index = 'sp_idx',
	species_names = 'Species',
	number_of_PCR = 43,
	alpha_magnitude = 0.1)

M5_output <- Run_Model(stan_object = M5, stan_data = stan_data_M5,
											 treedepth = 12,iterations = 2000,warmup = 1000)
```

## Extract outputs

```{r}
extract_amp_efficiecy(M5_output)
amp_eff_output_extract(M5_output)
```

```{r, include=FALSE, warning=FALSE, message=FALSE}
options(width = 1300) #wd
```

```{r, fig.width=17, fig.height=7}
extract_ini_prop(M5_output)
extract_ini_conc(M5_output)
```

```{r, include=FALSE, warning=FALSE, message=FALSE}
options(width = 300) #wd
```

## Plot outputs

```{r, fig.width=17, fig.height=7}
plot_amp_eff(M5_output)
bar_plot_est_ini_prop(M5_output)
heatmap_plot_est_ini_prop(M5_output)
plot_est_ini_conc(M5_output)
```

[Guri et al., 2024](https://onlinelibrary.wiley.com/doi/full/10.1002/ece3.70678) that are used in this script.

# All functions {#All_functions}

For step 1:\
`load_model(model)`\
\
For step 2:\
`prep_stan_M1(...)`\
`prep_stan_M2(...)`\
`prep_stan_M3(...)`\
`prep_stan_M4(...)`\
`prep_stan_M5(...)`\

For step 3:\
`Run_Model(stan_object, stan_data)`\
\
For step 4:\
`extract_qpcr_param(model_output)`\
`extract_est_conc(model_output)`\
`extract_amp_efficiecy(model_output)`\
`amp_eff_output_extract(model_output)`\
`extract_ini_prop(model_output)`\
`extract_ini_conc(M5_output)`\
\
For step 5:\
`plot_qpcr_prob_det(model_output,xmin_log, xmax_log)`\
`plot_qpcr_cont_mod(model_output,xmin_log, xmax_log)`\
`plot_qpcr_curves(model_output, xmin_log, xmax_log`\
`plot_qpcr_cont_mod_plate_specific(model_output, xmin_log, xmax_log)`\
`plot_est_conc(model_output)`\
`plot_amp_eff(model_output)`\
`bar_plot_est_ini_prop(model_output)`\
`heatmap_plot_est_ini_prop(model_output)`\
`plot_est_ini_conc(model_output, k = 2)`\
`diagnose_model()`\
